= ASM
:toc: left
:toclevels: 3

++++
<style>
p {
  font-family: "DejaVu Sans";
}
</style>
++++

== Flags registered

The CPU has a special register (called `EFLAGS` or `RFLAGS` on x64) where each individual bit is a "flag" that
records a property of the result of the most recent arithmetic or logical operation.

[cols="1,1,8"]
|===
|Flag Mnemonic |Name |Purpose

|ZF
|Zero Flag
|Set (1) if the result of the operation was *zero*; cleared (0) otherwise.

|SF
|Sign Flag
|Set (1) if the result of the operation was *negative* (i.e., the most significant bit is 1); cleared (0) otherwise.

|CF
|Carry Flag
|Set (1) if the operation resulted in an *unsigned overflow* (carry-out or borrow); cleared (0) otherwise.
|===


== Registers

The typical usage and naming conventions for registers in assembly are dictated by the system's
 *Application Binary Interface (ABI)*, 
which defines the "rules" for how functions interact, pass arguments, and manage memory.

=== 1. x86-64 (System V ABI - Linux/macOS)

The x86-64 architecture uses a *fast-call* convention, passing the first six
integer/pointer arguments via registers

[cols="2,2,5,2"]
|===
|Register (64-bit) |Low 32-bit |ABI Convention / Typical Usage |Volatility

|*%RAX* |%EAX |*Return Value* (first 64-bits); Temporary (volatile) |*Caller-Saved*
|*%RCX* |%ECX |*4th Argument* (Integer/Pointer) |Caller-Saved
|*%RDX* |%EDX |*3rd Argument* (Integer/Pointer) |Caller-Saved
|*%RDI* |%EDI |*1st Argument* (Integer/Pointer) |Caller-Saved
|*%RSI* |%ESI |*2nd Argument* (Integer/Pointer) |Caller-Saved
|*%R8 ‚Äì %R9* |%R8D ‚Äì %R9D |*5th and 6th Arguments* |Caller-Saved
|*%RSP* |%ESP |*Stack Pointer* (Must be preserved) |Callee-Saved
|*%RBP* |%EBP |*Base/Frame Pointer* (often ignored for speed) |Callee-Saved
|*%RBX, %R12‚Äì%R15* |%EBX, etc. |*Local Variables* (General Purpose) |*Callee-Saved*
|===

*Key Concepts*

* *Caller-Saved (Volatile)*: The calling function (caller) expects these registers to be
potentially overwritten by the called function (callee).
If the caller needs the value after the call, it must save it to the stack first.
* *Callee-Saved (Non-Volatile)*: The called function (callee) must preserve the original
value of these registers. If the callee modifies them, it must save the original value to
the stack and restore it before returning.

=== 2. ARM64 (AArch64 / AAPCS)

The ARM64 architecture is a *RISC* architecture that uses many registers, simplifying the call process.

[cols="1,3,1"]
|===
|Register (64-bit) |ABI Convention / Typical Usage |Volatility

|*X0 ‚Äì X7* |*Function Arguments* (1st to 8th) and *Return Value* (X0/X1) |*Caller-Saved*
|*X8* |Indirect Result Register (for large struct returns) / Temporary |Caller-Saved
|*X9 ‚Äì X15* |*Temporary / Scratch* registers for local data |Caller-Saved
|*X16 ‚Äì X17* |*IP0 / IP1* (Intra-Procedure-call scratch registers for linker) |Volatile
|*X19 ‚Äì X28* |*Local Variables* (General Purpose) |*Callee-Saved*
|*X29 (FP)* |*Frame Pointer* |Callee-Saved
|*X30 (LR)* |*Link Register* (holds the return address) |Volatile
|*X31 (SP)* |*Stack Pointer* (Stack operations) |N/A (Special)
|===

*Key Concepts*

* The first eight registers (__X0-X7__) are dedicated to argument passing, simplifying
function calls significantly.
* The *Link Register (LR/X30)* is explicitly used to store the return address, unlike x86
where the return address is pushed onto the stack.6 This is a common feature of RISC architectures.

=== 3. RISC-V (RV64)

RISC-V is a modern, modular RISC architecture. Its registers are often referred to by
their canonical ABI names.

[cols="1,1,5,1"]
|===
|Register (Index) |ABI Name |Typical Usage |Volatility

|*X0* |*zero* |*Hardwired to the constant value 0* (Cannot be written) |N/A
|*X1* |*ra* |*Return Address* (Link Register) |Caller-Saved
|*X2* |*sp* |*Stack Pointer* |Callee-Saved
|*X8, X9* |*s0, s1* |*Saved Registers* (Local Variables) |*Callee-Saved*
|*X10 ‚Äì X17* |*a0 ‚Äì a7* |*Function Arguments* (1st to 8th) and *Return Value* (a0/a1) |Caller-Saved
|*X28 ‚Äì X31* |*t3 ‚Äì t6* |*Temporary registers* (Scratch)| Caller-Saved
|===

*Key Concepts*

* *Zero Register (X0)*: A defining feature of RISC-V. It's a register you can read from to get 0,
but writes to it are ignored. This simplifies many instructions.
* *Named Registers*: Using names like a0 (Argument 0) and s0 (Saved Register 0) makes the assembly
 code much more readable and clearly enforces the calling convention.

=== Registers Physical Implementation

Logical registers (*RAX, RBX, X0, etc.*) represent physical storage locations within the CPU chip,
but their exact physical location and management are extremely complex and hidden from the programmer.

*1. Architectural vs. Microarchitectural Registers*

When you write assembly code, you are working with *Architectural Registers* (like RAX, RSP, RDI).
These are the 16 registers defined by the x86-64 Instruction Set Architecture (ISA).

However, modern CPUs (like Intel Core or AMD Ryzen) are designed for speed and use a technique called
*Register Renaming* to manage and optimize these resources.

*The Reality: The Physical Register File (PRF)*

The CPU does not just have 16 physical storage slots labeled "RAX" through "R15."
Instead, it has a much larger pool of general-purpose *Physical Registers*
(often 100 to 200 of them) called the *Physical Register File (PRF)*.

* When an instruction comes in, the CPU hardware maps the logical architectural register (RAX)
to one of the available physical registers in the PRF. This mapping is tracked by a special table
called the *Register Alias Table (RAT)*.


*2. Why Register Renaming is Necessary*

This complex physical mapping serves three critical purposes:

[cols="1,2,2"]
|===
|Purpose	|Explanation	|Example

|*Eliminating False Dependencies* |Solves the problem of
*Write-After-Read (WAR)* and *Write-After-Write (WAW)* hazards.
If two instructions both use `RAX`, the CPU can map them to two different physical registers,
allowing them to execute out-of-order without conflicts.
|Instruction 1 writes to __R~A~__. Instruction 2 also writes to __R~$~__.
The CPU maps __R~A~__ to __P~10~__ for Inst 1 and to __P~11~__ for Inst 2, letting them run independently.
|*Out-of-Order Execution*	|It allows instructions to be executed not in the order they appear in
the assembly code, but in the order that their data inputs become ready, dramatically speeding up the program.
|Instructions that don't depend on the previous instruction's result can jump ahead in the execution pipeline.
|*Speculative Execution* 
|It allows the CPU to guess the result of a conditional branch and execute instructions along that predicted path.
If the guess is wrong, the changes made to the PRF are simply discarded without affecting the architectural state.
|If the CPU guesses a jump is taken, it commits results to unused physical registers.
If the guess is wrong, it just frees those registers and continues.
|===

*Conclusion*

The registers are physical storage locations on the CPU die, but the architecture you program against (RAX, RBX)
 is a logical abstraction. The CPU dynamically assigns these logical names to a much larger pool of physical
 storage units behind the scenes to maximize parallelism and performance.

=== Caller Cellee Convention

That is a fundamental concept in assembly programming and one of the most critical aspects of any
*Application Binary Interface (ABI)*. It ensures that functions can call each other without unintentionally
destroying the data the caller needs.

The entire convention is a social contract or a *guarantee* established between a function that makes a call
(the *Caller*) and the function being called (the *Callee*).


==== 1. The Caller-Saved Convention

These registers are considered *temporary* or *volatile* (sometimes called "call-clobbered").

*The Rule*

If the *Caller* (Function A) has important data in a Caller-Saved register and wants that data to
survive a call to the *Callee* (Function B), *the Caller is responsible for saving the register's value
before the call and restoring it after the call*.

*Caller's Action (When needed)*

1. *Before the Call*: `push caller_saved_reg` (Saves the value to the stack).
1. *Call the Callee*: `call function_B`.
1. *After the Return*: `pop caller_saved_reg` (Restores the value from the stack).

*Callee's Privilege*

The Callee (Function B) can use and overwrite these registers freely without any obligation to save
or restore them, because the Caller has already assumed they will be destroyed.

*Common Usage*

* Registers used for passing function arguments (e.g., `%RDI`, `%RSI`, `%RAX` in x86-64).
* Registers used for short-lived, temporary scratch calculations within a function.

==== 2. The Callee-Saved Convention

These registers are considered *long-lived* or *non-volatile* (sometimes called "call-preserved").

*The Rule*

If the *Callee* (Function B) decides it needs to use or modify a Callee-Saved register, *the Callee*
*is responsible for preserving the original value and restoring it before returning*.
The Caller assumes the value will be unchanged.

*Callee's Action (When used)*

1. *Function Entry (Prologue)*: `push callee_saved_reg` (Saves the original value to the stack).
1. *Function Body*: The Callee uses the register for its own purposes.
1. *Function Exit (Epilogue)*: `pop callee_saved_reg` (Restores the original value from the stack,
 usually just before `ret`).

*Caller's Benefit*

The Caller (Function A) can safely store long-term variables (like loop counters or local pointers)
in Callee-Saved registers, knowing that any function it calls will automatically protect those values.
The Caller never has to worry about saving or restoring these.

*Common Usage*

* Registers used for local variables that must persist across nested function calls
 (e.g., `%RBX`, `%RBP`, `%R12-%R15` in x86-64).


==== Summary and Rationale

[cols="1,2,2"]
|===
|Feature |Caller-Saved (Volatile) |Callee-Saved (Non-Volatile)

|*Responsibility*	
|*Caller* must save if it needs the value later.	|*Callee* must save if it uses the register.
|*Purpose*
|Arguments, Return Value, Scratchpad.	
|Persistent Local Variables, Frame Pointers.
|*Trade-Off*
|Saves *Callee* instructions (faster calls).
|Saves *Caller* instructions (simpler code).
|===

*Why the Dual System? (The Optimization)*

This two-sided system is an optimization that minimizes redundant work:

1. *For Caller-Saved*: If a function (Caller) calls ten other functions but only needs one
    temporary value, it's inefficient for all ten Callees to save and restore a register
    they may not even use. It is better for the *Caller* to save only the one value it cares about.
1. *For Callee-Saved*: If a function (Caller) has a loop counter that must survive hundreds
    of internal function calls, it's far more efficient for the *Callee* (which only modifies the 
    egister once) to save and restore it, rather than forcing the Caller to save and restore the
    counter register around every single one of those hundreds of calls.

It's all about minimizing the total number of `push` and `pop` instructions executed across
the entire program.

üíª *Assembly Example: Callee-Saved Convention*

*The Caller's View (Function A)*

The Caller uses `%RBX` for a long-term variable and assumes the Callee will protect it.

```asm
; --- Function A (The Caller) ---

    mov rbx, 0xDEADBEEF ; Store an important value in a
                        ; Callee-Saved register (RBX)

    ; We call my_function. We DO NOT save RBX, because it's the CALLEE's job.
    call my_function

    ; After my_function returns, we expect RBX to STILL be 0xDEADBEEF.
    ; If it isn't, my_function violated the ABI contract.
    cmp rbx, 0xDEADBEEF ; This comparison should succeed (ZF=1)
    ; ...
```

*The Callee's Implementation (my_function)*

The Callee must save and restore `%RBX` if it intends to use it. This save/restore process
 is the definition of the function's *Prologue* and *Epilogue*.

```asm
 ; --- my_function (The Callee) ---

my_function:
; ---------- PROLOGUE (Function Setup) ----------

    ; 1. Preserve the Callee-Saved registers that we will modify.
    push rbx ; Save the Caller's original RBX value onto the stack
    
    ; Note: A function would usually also save RBP and set up the stack frame here
    ; push rbp
    ; mov rbp, rsp
    
; ---------- FUNCTION BODY ----------

    ; We are free to use RBX now, knowing we have a copy of the original value saved.
    mov rbx, 12345678    ; Overwrite RBX for our own calculation
    ; ... (lots of code using RBX) ...

; ---------- EPILOGUE (Function Cleanup) ----------

    ; 1. Restore the Callee-Saved registers.
    pop rbx ; Restore the Caller's original RBX value from the stack.
    
    ; Note: If we saved RBP, we would restore it here
    ; pop rbp
    
    ; 2. Return control to the Caller.
    ret ; Jumps back to the instruction immediately following the 'call'
```

*Key Steps Visualized*

The stack grows downward (to lower addresses). The `push` operation moves the
Stack Pointer (`RSP`) down and stores the register content. The pop operation
retrieves the data and moves the `RSP` back up.

In essence, the Callee-Saved convention guarantees that the memory location
holding the original value of `%RBX` is treated as sacred by the called function.
If the Callee needs the register, it temporarily copies the sacred value to the
stack and restores it before leaving.

=== Argument/Return Roles

==== 1. The Argument Passing Role
When a function (`Caller`) decides to execute another function (`Callee`), it needs
 to send input data (the function's arguments) to the `Callee`.

Instead of pushing all arguments onto the slow stack memory, modern ABIs
  (like x86-64 and ARM64) use specific, fast CPU registers for the first few arguments.
  These are the registers listed in the "Argument" category.

üí° The Rule for Arguments (x86-64)

The first six integer or pointer arguments are placed into the following registers, in order:

[%header, cols="1,1,2"]
|===
|Argument # |Register |Example in C Code

|*1st* |%RDI |`int func(int a, ...)`
|*2nd* |%RSI |`int func(..., int b, ...)`
|*3rd* |%RDX |`int func(..., int c, ...)`
|*4th* |%RCX |`int func(..., int d, ...)`
|*5th* |%R8  |`int func(..., int e, ...)`
|*6th* |%R9  |`int func(..., int f)`
|===

If a function needs more than six arguments, the remaining arguments are pushed onto the stack.

*Example:*

For the C call `sum(10, 20)`, the compiler generates assembly that does this *before* the call instruction:
```asm
mov rdi, 10    ; Set 1st argument (10)
mov rsi, 20    ; Set 2nd argument (20)
call sum_function
```

==== 2. The Return Value Role
When the called function (`Callee`) finishes its work, it needs a standardized way to send
 its output (the return value) back to the `Caller`.

üí° The Rule for Return Values (x86-64)

The result of the function is always placed in a dedicated register: `%RAX`.

* *If the function returns a 64-bit integer, a pointer, or a smaller value, it goes into %RAX*.
* If the return value is larger than 64 bits (e.g., a large structure), it might use both
  `%RAX` and `%RDX` or a pointer to a stack location.

*Example:*

Inside `sum_function`:
```asm
; ... (calculation) ...
mov rax, final_result ; Place the final result into RAX
ret                   ; Return to the caller
```

==== Summary of the "Argument/Return" Group
The registers categorized as "Argument/Return" are the registers that are guaranteed
 to be used for the I/O of a function call.

Because they are used for I/O, they are also classified as *Caller-Saved* (volatile).
 The calling function expects these registers to be overwritten, either by arguments
  it is setting up or by the return value that overwrites the previous contents of `%RAX`.

== Assembly Coding format

Assembly language code is traditionally structured into four main columns or fields,
 though modern assemblers are often flexible with spacing and capitalization.

The two fields you are asking about are the *Opcode/Mnemonic* (the "operator")
 and the Operands (the data/registers being operated on).

=== Standard Assembly Format

The standard format is a sequence of four fields, usually separated by
 whitespace (spaces or tabs):
[cols="1,2,1,1"]
|====
|Field #1 |Field #2 |Field #3 |Field #4

|*Label* |*Opcode/Mnemonic* |*Operands* |*Comment*
|====

==== The Operator (Opcode/Mnemonic)

The operator (often called the *Mnemonic*) sits in the *second column*.
 This is the instruction itself, defining the action the CPU will take.

==== Examples
`mov`, `add`, `test`, `jmp`, `call`, `push`, `pop`.

==== The Operands

The operands sit in the *third column*. These are the targets of the instruction‚Äîthe registers,
 memory locations, or immediate values (constants) that the operation will use or modify.

==== Format
Operands are listed after the Opcode and are separated by a comma (`,`).

==== Example

```ams
; Field 1       Field 2      Field 3 (Operands)   Field 4
; Label         Opcode       Destination, Source  Comment

start:          mov          rax, 0x10            ; Load a constant value into RAX
                add          rax, rbx             ; Add the contents of RBX to RAX
                test         rax, rax             ; Fast check if RAX is zero
                jnz          continue_label       ; Jump if RAX is Not Zero
continue_label: push         rdi                  ; Save RDI onto the stack
```

=== Addressing Operand Order

A critical point about the *third column (Operands)* is the order:

* *Intel Syntax (Used in Windows/macOS/Intel manuals)*: 
  Destination comes first, Source comes second.
  ** `mov destination, source` (e.g., `mov rax, rbx` = RAX <= RBX)
* *AT&T Syntax (Used in Linux/GNU assemblers)*:
  Source comes first, Destination comes second.
  ** `mov source, destination` (e.g., `mov %rbx, %rax` = RAX => RBX)

== Asm Ops

=== `cbz`
Compare and Branch on Zero

* ARM64 instruction
* specialized control-flow instruction
* combines a comparison and a conditional jump into a single instruction
* opposite `cbnz`

üîç *How CBZ Works*

The instruction checks whether a specific register
contains the value *0*. Based on that result, it either "takes" the branch
or continues to the next line of code.

. *The Test*: The CPU inspects the value in the source register (_Rn_).
. *The Condition*: *If the register is 0*: The program jumps (branches)
 to the specified label.
 
 * *If the register is NOT 0*: The program simply moves to the next instruction
  in sequence (falls through).
 * *No Flags Changed*: Unlike the standard `CMP` (Compare) instruction,
   *CBZ does not update the condition flags* (Negative, Zero, Carry, Overflow).
   This is useful if you want to branch based on a zero check without
   overwriting flags set by a previous operation.
   
üõ†Ô∏è *Syntax and Format*

In ARM64 (AArch64), the syntax is: `CBZ <Xt|Wt>, <label>`

* `<Xt|Wt>`: The 64-bit (X) or 32-bit (W) register to check.
* `<label>`: The destination address (encoded as a PC-relative offset).

*Logic Representation*
‚öñÔ∏è CBZ vs. Standard CMP/BEQ
In most assembly languages, checking for zero requires two steps. ARM allows you to do it in one:
If (R~n~ = 0) then (PC <- PC + offset)

‚öñÔ∏è *CBZ vs. Standard CMP/BEQ*

In most assembly languages, checking for zero requires two steps. ARM allows you to do it in one:

[cols="1,1,3"]
|===
|Method |Instructions |Explanation

|*Traditional*  |`CMP W0, #0` `B.EQ label` |Compare register with #0 (sets flags), then branch if Equal flag is set.
|*CBZ*          |`CBZ W0, label`  |Check for zero and branch immediately. Flags remain untouched.
|===

*Why use CBZ?*

* *Code Density*: It saves 4 bytes of code space by using one instruction instead of two.
* *Performance*: It can reduce the "pressure" on the CPU's execution units,
 as the branch logic is more streamlined.
* *Flag Preservation*: It allows you to perform a check "on the side" without ruining the
 results of a previous mathematical operation that you might need to check later.

‚ö†Ô∏è *Important Limitations*

* *Range*: In ARM64, the branch range is limited to *¬±1 MB* from the current instruction.
 For very distant jumps, you must use a standard CMP and B (which has a much larger range).
* *Zero Only*: You can only use CBZ to check for zero. You cannot use it to check 
 if a register equals `5` or any other constant.

---

=== `cmovne`
Conditional Move Not Equal

* x89-64 instruction
* part of the conditional ove instruction set
* It provides a way to conditionally transfer data
between registers or between a memory location and a register 
*without using a traditional branch/jump instruction*

üíª *How CMOVNE Works*

The instruction format is generally: `CMOVNE destination, source`

. *Check the Zero Flag (ZF)*: The `CMOVNE` instruction inspects the
*Zero Flag (ZF)* in the `RFLAGS` register. The Zero Flag is typically
set or cleared by a preceding instruction, such as a `CMP` (Compare)
or an arithmetic/logical operation.
. Condition: The "NE" in `CMOVNE` stands for *Not Equal*. The move operation
is executed *if the Zero Flag (ZF) is 0*.
* *Condition Met (ZF = 0)*: This means the previous comparison/operation
resulted in a non-zero outcome, which typically signifies that the two compared
operands were *not equal*. In this case, the value in the `source` operand is
copied to the `destination` operand.
* *Condition Not Met (ZF = 1)*: This means the previous comparison/operation
resulted in a *zero* outcome, which typically signifies that the two compared
operands were *equal*. In this case, the move *does not occur*, and the
`destination` operand retains its original value.

== Cute Gist/Patterns

=== System Call
*Objective*

Request services from Linux kernel (I/O, exit, etc.)

*x86-64*
```asm
mov rax, 60 ; exit
xor rdi, rdi
syscall
```

*Explanation*
```asm
mov rax, syscall_number
syscall
```

*ARM*
```asm
mov x8, #93 ; exit
mov x0, #0
svc #0
```

*Explanation*
```asm
mov x8, syscall_number
svc #0
```

=== Function Prologue/Epilogue

*x86-64*

* Nomenclature: __Prologue__, __Epilogue__
* Objective: Set up and tear down stack frames for function calls.

*Sample*
```asm
push %rbp         ; save base pointer
mov  %rsp, %rbp   ; set new base pointer
...
mov  %rbp, %rsp   ; restore stack pointer
pop  %rbp         ; restore base pointer
ret               ; return to caller
```
*ARM68*

* Nomenclature: STP/LDP, RET
* Objective: Save/restore registers and manage stack frames.

*Sample*
```asm
stp x29, x30, [sp, #-16]! ; save FP & LR
mov x29, sp               ; set frame pointer
...
ldp x29, x30, [sp], #16   ; restore FP & LR
ret
```

=== The Fast Zero check
This is the most descriptive name, highlighting its primary function.
 The sequence is the most efficient and concise way to determine
 if a register's value is zero.

* It checks the *Zero Flag (ZF)* without changing the register's value.
* On modern CPUs, `test reg, reg` often has better performance characteristics than
  `cmp reg, 0` because it avoids needing to encode and handle an immediate (constant) zero operand.
  It can also often `macro-fuse` with the subsequent conditional jump (`jne` or `je`)
  into a single micro-operation (uop), which improves execution speed.

==== How Flags are Affected

When executing `test rax, rax`:

* If `rax` is 0: The result of the operation is 0 AND 0 = 0.
  The *Zero Flag (ZF)* is set to 1 (true), indicating a zero result.
* If `rax` is *non-zero*: The result of the operation is non-zero.
  The *Zero Flag (ZF)* is set to 0 (false), indicating a non-zero result.

==== Coding Samples

*x86-64*
```asm
test    rax, rax
jz      .is_zero
```
__Why it‚Äôs elegant__

* No immediate
* No register modification
* Short encoding
* Sets ZF, SF, PF correctly

.Compilers strongly prefer `test reg, reg` over `cmp reg, 0`.

*ARM64*
```asm
cbz     x0, .is_zero
```
Or, when flags are needed later:

```asm
cmp     x0, #0
b.eq    .is_zero
```
__Why ARM is nicer here__

* `CBZ/CBNZ` fuses compare + branch
* Often 1 ¬µop internally

=== The Non-Destructive Zero Test
This name focuses on the key advantage over other instructions like `AND` or `OR` when
used for the same purpose:

[cols="1,1,1"]
|===
|Instruction |Behavior |Change to Register Value?

|`test rax, rax` |rax¬†AND¬†rax (Flags only)  |*No*
|`and  rax, rax` |rax=rax¬†AND¬†rax           |Yes (But always the same value)
|`or   rax, rax` |rax=rax¬†OR¬†rax            |Yes (But always the same value)
|===

While `and rax, rax` and `or rax, rax` also set the flags correctly for a zero check,
  they are considered *destructive* operations (even though the value doesn't change,
  the instruction is treated as writing a result to `rax`).
  This can create a "false dependency" for the CPU's out-of-order execution engine,
  potentially causing stalls.

The `test` instruction is explicitly designed to be *non-destructive* (flags only),
  which allows subsequent instructions that read `rax` to proceed without waiting
  for the test operation to finish, leading to higher performance.

So, while there's no single catchy mnemonic like "The Test-Jump Sequence," calling
  it the *Fast Zero Check* or emphasizing its *Non-Destructive* nature captures its
  essence and efficiency.

=== Fast Equality Check Against Zero (Return Value Test)

*Nomenclature*

*Proposed*: __Booleanization via Flags__

*Common compiler term*: __setcc idiom__

*Pattern*

Convert a value into `0` or `1` without branching.

*x86-64*
```asm
test    rax, rax
setz    al
```
or signed:
```asm
test    rax, rax
setg    al      ; > 0
```
__Why it‚Äôs used__

* Branchless
* Feeds well into vectorized or speculative code

=== Zero Register via XOR / Self-Move Elimination
(Canonical)

*Zeroing Idiom* (compiler terminology)

*Purpose*

Set a register to zero *as fast as possible*

*x86-64*
```asm
xor rax, rax
```
*Explanation*

* `rax XOR rax = 0`
* Faster than `mov rax, 0`
* Breaks dependency chains (important for out-of-order CPUs)

*ARM64*
```asm
mov x0, xzr
```
*Explanation*

* `xzr` is a *hardware zero register*
* Reading from it always yields `0`
* Writing to it discards data

=== Fast Boolean Normalize (0 or 1)
(Canonical)

*Boolean Canonicalization*

*Purpose*

Convert any non-zero value into `1`, zero stays `0`

*x86-64*
```asm
test rax, rax
setnz al
```
*Explanation*

* setnz al sets the low byte:
** 1 if non-zero
** 0 if zero

*ARM64*
```asm
cmp  x0, #0
cset x0, ne
```
*Explanation*

* `cset` = *conditional set*
* Writes `1` if condition true, else `0`

=== Branchless Select (Ternary Operator)
(Canonical, very important)

*Branchless Conditional Move*

*Purpose*

Equivalent to:
```c
result = condition ? a : b;
```
*x86-64*
```asm
cmp    rax, 0
cmovne rbx, rcx
```
*Explanation*

* `cmovne` = conditional move if not zero
* No branch ‚Üí no misprediction penalty

*ARM64*
```asm
cmp  x0, #0
csel x1, x2, x3, ne
```
*Explanation*

* `csel` = *conditional select*
* Picks `x2` or `x3` based on condition

=== Fast Sign Extraction

(Canonical, used in math, SIMD, crypto)

*Pattern Name*

Sign Mask Extraction


*Purpose*

* Extract sign (-1 or 0) from a signed integer


*x86-64*
```asm
sar rax, 63
```

*Explanation*

* Arithmetic shift right
* Fills with sign bit
* Result:
** 0 if positive
** -1 if negative

*ARM64*
```asm
asr x0, x0, #63
```

=== Absolute Value (Branchless)

(Canonical)

*Pattern Name*

Branchless Absolute Value

*x86-64*
```asm
mov rbx, rax
sar rbx, 63
xor rax, rbx
sub rax, rbx
```

*Explanation*

* Compute sign mask
* Flip bits if negative
* Subtract correction

*ARM64*
```asm
asr x1, x0, #63
eor x0, x0, x1
sub x0, x0, x1
```

=== Power-of-Two Check

(Canonical)

*Pattern Name*

Single-Bit Test

*Purpose*

Check if x is a power of two

*x86-64*
```asm
test rax, rax
jz   not_power
lea  rcx, [rax - 1]
test rax, rcx
jz   is_power
```

*Explanation*

Power of two has *exactly one bit set*

*ARM64*
```asm
cbz  x0, not_power
sub  x1, x0, #1
ands xzr, x0, x1
b.eq is_power
```

=== Fast Range Clamp (Branchless)

(Compiler-generated idiom)

*Pattern Name*

Branchless Clamp

*Purpose*
```asm
x = min(max(x, lo), hi)
```

*x86-64*
```asm
cmp   rax, rbx
cmovl rax, rbx
cmp   rax, rcx
cmovg rax, rcx
```

*ARM64 (best here)*
```asm
cmp  x0, x1
csel x0, x1, x0, lt
cmp  x0, x2
csel x0, x2, x0, gt
```

=== Fast Null Pointer Check

(Canonical)

*Pattern Name*

Null Test Idiom

*x86-64*
```asm
test rdi, rdi
jz   is_null
```

*ARM64*
```asm
cbz x0, is_null
```

=== Strength-Reduced Multiplication (Multiply by Constant)

(Compiler canonicalization)

*Pattern Name*

Strength Reduction

*Purpose*

Replace multiplication with shifts/adds

*x86-64*
```asm
lea rax, [rdi + rdi*4]  ; x * 5
```

*ARM64*
```asm
add x0, x0, x0, lsl #2
```

=== Loop/Counter Decrement Pattern

*Purpose*

This is critical for all assembly loops (like for and while loops).

[cols="1.1.2"]
|===
|Pattern	    |Nomenclature	    |Purpose

|`dec reg`	  |*The Decrement and Check*	| Decrements a counter and sets the flags based on the new value.
|`j(ne/nz) somewhere` | . |Checks if the counter has reached zero.
|===

üîç *How it Works*

`dec reg` subtracts 1 from the register and sets the flags based on the result.

* If the result is 0, the *Zero Flag (ZF)* is set to 1.
* If the result is non-zero, the *Zero Flag (ZF)* is cleared to 0.

==== Coding Sample
(A simple loop)
```asm
loop_start:
    ; ... loop body ...
    dec rcx            ; Decrement counter
    jnz loop_start     ; Jump if Not Zero (RCX != 0)
```

=== Arithmetic Check Pattern

*Purpose*

Any arithmetic operation implicitly sets the flags,
 which can be immediately followed by a jump.
 This avoids a separate `cmp` or `test` instruction entirely.

[cols="2,1,5"]
|===
|Pattern	    |Nomenclature	    |Purpose

|`add/sub reg, op / inc/dec reg`  |*Inline Flag Set*  |Checks if an arithmetic result satisfied a condition (e.g., if an addition overflowed or if a subtraction resulted in zero).
|`j(cond) somewhere`  | . |Implements logic like `if (addition_overflowed) or if (result == 0).`
|===

üîç *How it Works*

The instruction performs the arithmetic, and the flags (like *CF*
 for carry/unsigned overflow and *OF* for signed overflow) are set.

==== Coding Sample
```asm
add   rax, rbx          ; RAX = RAX + RBX. CF is set if unsigned overflow occurred.
jc    overflow_error    ; Jump if Carry (i.e., unsigned overflow)
```

== x86-64 and ARM64 Common Patterns

=== üñ•Ô∏è x86-64 Common Patterns

==== Function Prologue / Epilogue
* *Nomenclature*: __Prologue__, __Epilogue__
* *Objective*: Set up and tear down stack frames for function calls.

===== Sample:
```asm
push %rbp         ; save base pointer
mov  %rsp, %rbp   ; set new base pointer
...
mov  %rbp, %rsp   ; restore stack pointer
pop  %rbp         ; restore base pointer
ret               ; return to caller
```

=== Register Usage Conventions
* *Nomenclature*: __Caller-saved__ vs __Callee-saved registers__
* *Objective*: Manage which registers must be preserved across function calls.

==== Sample: 
`%rax` often holds return values, `%rsp` is the stack pointer.


=== Data Movement
* *Nomenclature*: __MOV__, __PUSH__/__POP__
* *Objective*: Transfer data between registers and memory.

==== Sample:
```asm
mov  %rax, %rbx   ; copy value
push %rcx         ; save register on stack
pop  %rcx         ; restore register
```

=== Arithmetic and Logic
* *Nomenclature*: __ADD__, __SUB__, __IMUL__, __AND__, __OR__
* *Objective*: Perform basic math and bitwise operations.

==== Sample:
```asm
add  $5, %rax     ; add immediate
imul %rbx, %rax   ; multiply
```

=== Branching
* *Nomenclature*: __CMP__, __JMP__, __JE__/__JNE__
* *Objective*: Conditional and unconditional control flow.

==== Sample:
```asm
cmp %rax, %rbx
je  equal_label
jmp end_label
```

=== üì±ARM64 Common Patterns

==== Function Prologue / Epilogue
* *Nomenclature*: __STP__/ __LDP__, __RET__
* *Objective*: Save/restore registers and manage stack frames.

==== Sample:
```asm
stp x29, x30, [sp, #-16]! ; save FP & LR
mov x29, sp               ; set frame pointer
...
ldp x29, x30, [sp], #16   ; restore FP & LR
ret
```

=== Data Movement
* *Nomenclature*: __MOV__, __LDR__, __STR__, __ADR__
* *Objective*: Move values between registers and memory.

==== Sample:
```asm
mov x0, #5        ; immediate to register
ldr x1, [x2]      ; load from memory
str x1, [x2]      ; store to memory
adr x3, label     ; load address
```

=== Arithmetic and Logic
* *Nomenclature*: __ADD__, __SUB__, __MUL__, __AND__, __ORR__
* *Objective*: Perform math and bitwise operations.

==== Sample:
```asm
add x0, x1, x2    ; x0 = x1 + x2
sub x3, x4, #1    ; decrement
```

=== Branching
* *Nomenclature*: __B__, __BL__, __CBZ__/__CBNZ__
* *Objective*: Control flow and function calls.

==== Sample:
```asm
cbz x0, zero_label   ; branch if zero
bl  func_label       ; branch with link (function call)
b   end_label        ; unconditional branch
```

=== Register Conventions
* *Nomenclature*: __x0__‚Äì__x7__ (function arguments), __x0__ (return value)
* *Objective*: Standard calling convention for passing parameters.


=== üîë Key Takeaway
* *x86-64* emphasizes stack-based calling conventions with `%rsp` and `%rbp`.
* *ARM64* emphasizes register-based calling conventions with `x0‚Äìx7` for arguments.
* Both architectures share common instruction categories:
 *data movement, arithmetic, branching, and function call setup/teardown*.
