= ASM
:toc: left
:toclevels: 3

++++
<style>
p {
  font-family: "DejaVu Sans";
}
</style>
++++

=== Flags registered

The CPU has a special register (called `EFLAGS` or `RFLAGS` on x64) where each individual bit is a "flag" that
records a property of the result of the most recent arithmetic or logical operation.

[cols="1,1,8"]
|===
|Flag Mnemonic |Name |Purpose

|ZF
|Zero Flag
|Set (1) if the result of the operation was *zero*; cleared (0) otherwise.

|SF
|Sign Flag
|Set (1) if the result of the operation was *negative* (i.e., the most significant bit is 1); cleared (0) otherwise.

|CF
|Carry Flag
|Set (1) if the operation resulted in an *unsigned overflow* (carry-out or borrow); cleared (0) otherwise.
|===


=== Registers

The typical usage and naming conventions for registers in assembly are dictated by the system's
 *Application Binary Interface (ABI)*, 
which defines the "rules" for how functions interact, pass arguments, and manage memory.

==== 1. x86-64 (System V ABI - Linux/macOS)

The x86-64 architecture uses a *fast-call* convention, passing the first six
integer/pointer arguments via registers

[cols="2,2,5,2"]
|===
|Register (64-bit) |Low 32-bit |ABI Convention / Typical Usage |Volatility
|*%RAX* |%EAX |*Return Value* (first 64-bits); Temporary (volatile) |*Caller-Saved*
|*%RCX* |%ECX |*4th Argument* (Integer/Pointer) |Caller-Saved
|*%RDX* |%EDX |*3rd Argument* (Integer/Pointer) |Caller-Saved
|*%RDI* |%EDI |*1st Argument* (Integer/Pointer) |Caller-Saved
|*%RSI* |%ESI |*2nd Argument* (Integer/Pointer) |Caller-Saved
|*%R8 – %R9* |%R8D – %R9D |*5th and 6th Arguments* |Caller-Saved
|*%RSP* |%ESP |*Stack Pointer* (Must be preserved) |Callee-Saved
|*%RBP* |%EBP |*Base/Frame Pointer* (often ignored for speed) |Callee-Saved
|*"%RBX, %R12–%R15* |%EBX, etc." |*Local Variables* (General Purpose) |*Callee-Saved*
|===

*Key Concepts*

* *Caller-Saved (Volatile)*: The calling function (caller) expects these registers to be
potentially overwritten by the called function (callee).
If the caller needs the value after the call, it must save it to the stack first.
* *Callee-Saved (Non-Volatile)*: The called function (callee) must preserve the original
value of these registers. If the callee modifies them, it must save the original value to
the stack and restore it before returning.

==== 2. ARM64 (AArch64 / AAPCS)

The ARM64 architecture is a *RISC* architecture that uses many registers, simplifying the call process.

[cols="1,3,1"]
|===
}Register (64-bit) |ABI Convention / Typical Usage |Volatility
|*X0 – X7* |*Function Arguments* (1st to 8th) and *Return Value* (X0/X1) |*Caller-Saved*
|*X8* |Indirect Result Register (for large struct returns) / Temporary |Caller-Saved
|*X9 – X15* |*Temporary / Scratch* registers for local data |Caller-Saved
|*X16 – X17* |*IP0 / IP1* (Intra-Procedure-call scratch registers for linker) |Volatile
|*X19 – X28* |*Local Variables* (General Purpose) |*Callee-Saved*
|*X29 (FP)* |*Frame Pointer* |Callee-Saved
|*X30 (LR)* |*Link Register* (holds the return address) |Volatile
|*X31 (SP)* |*Stack Pointer* (Stack operations) |N/A (Special)
|===

*Key Concepts*

* The first eight registers (__X0-X7__) are dedicated to argument passing, simplifying
function calls significantly.
* The *Link Register (LR/X30)* is explicitly used to store the return address, unlike x86
where the return address is pushed onto the stack.6 This is a common feature of RISC architectures.

==== 3. RISC-V (RV64)

RISC-V is a modern, modular RISC architecture. Its registers are often referred to by
their canonical ABI names.

[cols="1,1,5,1"]
|===
|Register (Index) |ABI Name |Typical Usage |Volatility
|*X0* |*zero* |*Hardwired to the constant value 0* (Cannot be written) |N/A
|*X1* |*ra* |*Return Address* (Link Register) |Caller-Saved
|*X2* |*sp* |*Stack Pointer* |Callee-Saved
|*X8, X9* |*s0, s1* |*Saved Registers* (Local Variables) |*Callee-Saved*
|*X10 – X17* |*a0 – a7* |*Function Arguments* (1st to 8th) and *Return Value* (a0/a1) |Caller-Saved
|*X28 – X31* |*t3 – t6* |*Temporary registers* (Scratch)| Caller-Saved
|===

*Key Concepts*

* *Zero Register (X0)*: A defining feature of RISC-V. It's a register you can read from to get 0,
but writes to it are ignored. This simplifies many instructions.
* *Named Registers*: Using names like a0 (Argument 0) and s0 (Saved Register 0) makes the assembly
 code much more readable and clearly enforces the calling convention.

