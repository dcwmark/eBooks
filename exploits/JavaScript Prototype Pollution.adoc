=== JavaScript Prototype Pollution

==== 1. The Core Injection Chain

Before you can exploit a chain, you have to get the payload in. This usually happens through **recursive merges, path setters,** or **cloning functions**.

**The Logic:**

If an application takes a JSON input and merges it into an existing object without filtering keys, an attacker can send:

```json
{
  "constructor": {
    "prototype": {
      "isAdmin": true
    }
  }
}
```

Once processed, every object in the environment—even a brand new `{}` — will now have `obj.isAdmin === true`.

==== 2. Client-Side: The DOM XSS Chain

On the frontend, prototype pollution is rarely the end goal; it’s a means to trigger **Cross-Site Scripting (XSS)**. This happens by polluting "gadgets" — pieces of code that look for a property and use it in a dangerous sink.

**The Chain:**

. **The Pollution:** Attacker pollutes `Object.prototype.sourceURL = "javascript:alert(1)"`.
. **The Gadget:** A legitimate library (like a slider or tracker) creates a new configuration object.
. **The Vulnerability:** The library checks if `config.sourceURL` exists. Since it’s polluted, it finds the attacker's string.
. **The Sink:** The library passes that string into a script tag or `location.href`.

==== 3. Server-Side: The RCE Chain (Node.js)

In Node.js environments, the stakes are higher. Attackers look for gadgets within the Node.js source or popular modules (like `child_process`) to achieve **Remote Code Execution (RCE)**.

**Common Gadget:** `child_process.spawn`

Many Node utilities use `spawn` or `fork`. These functions often accept an `options` object. If the developer doesn't explicitly define certain environment variables, the system looks them up on the prototype.

* The Chain:
** Pollute `Object.prototype.shell = "/bin/sh"`.
** Pollute `Object.prototype.NODE_OPTIONS = "--inspect-brk=0.0.0.0"`.
** Wait for the server to execute any system command (like a maintenance script or image processor).
** The spawned process inherits the polluted `shell` or `NODE_OPTIONS`, giving the attacker a  or a debug port.

==== 4. The Logic Bypass Chain

Sometimes, the goal isn't to crash the server or steal cookies, but to bypass authorization.

* The Chain:

[cols="1,2,8"]
|===
|Step
|Action|
Result
|1
|Identify a check
|`if (user.permissions.canDelete)`
|2
|Inject Pollution
|`Object.prototype.canDelete = true`
|3
|Execute
|An unprivileged user now passes the `if` check because the property is found on the prototype.
|===

==== How to Break the Chain

To stop these attacks, you have to prevent the "merging" of untrusted keys

* **Use** `Map`: Instead of plain objects for key-value storage, use `Map`, which isn't susceptible to prototype pollution.
* **Object.create(null)**: Create objects that don't have a prototype at all.
* **Validation**: Use libraries like `joi` or `ajv` to strictly validate the schema of incoming JSON.
* **Freeze the Prototype**: Run `Object.freeze(Object.prototype)` at the very start of your application to prevent any changes (though this can break some legacy libraries).

