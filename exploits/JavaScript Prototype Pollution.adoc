=== JavaScript Prototype Pollution

==== 1. Common Pollution Vectors

===== 1. Recursive Merge Pollution

This is the most common vector, found in merge/extend functions that don't properly sanitize keys:

[source,javascript]
----
function merge(target, source) {
  for (let key in source) {
    if (typeof source[key] === 'object') {
      if (!target[key]) target[key] = {};
      merge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
}

// Exploitation
let payload = JSON.parse('{"__proto__": {"isAdmin": true}}');
merge({}, payload);

let user = {};
console.log(user.isAdmin); // true - polluted!
----

===== 2. Path Assignment Pollution

Libraries like lodash (pre-patched versions) that set values by string paths:

[source,javascript]
----
function set(obj, path, value) {
  let keys = path.split('.');
  let current = obj;
  
  for (let i = 0; i < keys.length - 1; i++) {
    if (!current[keys[i]]) current[keys[i]] = {};
    current = current[keys[i]];
  }
  
  current[keys[keys.length - 1]] = value;
}

// Exploitation
set({}, '__proto__.polluted', true);
console.log({}.polluted); // true
----

===== 3. Constructor Pollution

Polluting via the `constructor` property:

[source,javascript]
----
let obj = {};
obj.constructor.prototype.isAdmin = true;

let newUser = {};
console.log(newUser.isAdmin); // true
----

==== 2. The Core Injection Chain

Before you can exploit a chain, you have to get the payload in. This usually happens through **recursive merges, path setters,** or **cloning functions**.

**The Logic:**

If an application takes a JSON input and merges it into an existing object without filtering keys, an attacker can send:

[source,json]
----
{
  "constructor": {
    "prototype": {
      "isAdmin": true
    }
  }
}
----

Once processed, every object in the environment—even a brand new `{}` — will now have `obj.isAdmin === true`.

==== 3. Client-Side: The DOM XSS Chain

On the frontend, prototype pollution is rarely the end goal; it’s a means to trigger **Cross-Site Scripting (XSS)**. This happens by polluting "gadgets" — pieces of code that look for a property and use it in a dangerous sink.

**The Chain:**

. **The Pollution:** Attacker pollutes `Object.prototype.sourceURL = "javascript:alert(1)"`.
. **The Gadget:** A legitimate library (like a slider or tracker) creates a new configuration object.
. **The Vulnerability:** The library checks if `config.sourceURL` exists. Since it’s polluted, it finds the attacker's string.
. **The Sink:** The library passes that string into a script tag or `location.href`.

==== 4. Server-Side: The RCE Chain (Node.js)

In Node.js environments, the stakes are higher. Attackers look for gadgets within the Node.js source or popular modules (like `child_process`) to achieve **Remote Code Execution (RCE)**.

**Common Gadget:** `child_process.spawn`

Many Node utilities use `spawn` or `fork`. These functions often accept an `options` object. If the developer doesn't explicitly define certain environment variables, the system looks them up on the prototype.

* The Chain:
** Pollute `Object.prototype.shell = "/bin/sh"`.
** Pollute `Object.prototype.NODE_OPTIONS = "--inspect-brk=0.0.0.0"`.
*** This payload is a classic example of an *RCE (Remote Code Execution) gadget*. It exploits how Node.js handles environment variables and process spawning.

  The "Pollution" Mechanism::
  When `Object.prototype.NODE_OPTIONS = "..."` is executed, the "base template" of almost every object in the Node.js process can be affected. +
  In Node.js, when a developer uses functions like `child_process.spawn()` or `child_process.fork()`, the runtime looks for an `options` object to determine how to run the new process. If the developer doesn't explicitly provide an `env` object, or if they provide one that doesn't define `NODE_OPTIONS`, the engine looks up the prototype chain.
  The Payload: `--inspect-brk`::
  The value being injected is a powerful Node.js command-line flag:
  . `--inspect`: Enables the V8 inspector (debugging).
  . `-brk`: Tells the process to "break" (pause) on the very first line of code and wait for a debugger to attach.
  . `0.0.0.0`: This binds the debugger to all network interfaces, making it accessible from the outside world (rather than just `localhost`).
  The Attack Chain::
  The "pollution-to-RCE" chain usually follows these steps:
  . *Injection*: An attacker uses a vulnerable merge or clone function to inject the NODE_OPTIONS string into Object.prototype.
  . *Trigger*: The application performs a routine task that spawns a sub-process (e.g., calling a CLI tool to resize an image, send an email, or run a shell script).
  . *Inheritance*: The spawn() function looks for environment variables. It finds the polluted NODE_OPTIONS on the prototype.
  . *Execution*: The new Node.js process starts, sees the flag, and immediately pauses execution, opening a debugging port on the server.
  . *RCE*: The attacker connects to that port using Chrome DevTools or a Node debugger and executes arbitrary JavaScript code with the same privileges as the server.
  Why is this so dangerous?::
  This is considered a "silent" killer because:
  . *No direct shell needed*: The attacker doesn't need to find a way to run `/bin/sh` directly; they just wait for the app to do its normal job.
  . *Persistence*: Once the prototype is polluted, every subsequent process spawned by that Node.js instance will be "born" in debug mode.
  How to Prevent It::
  The most effective way to stop this specific chain is to ensure that when you spawn child processes, you don't allow them to inherit the global prototype's properties.
  Bad (Vulnerable)::
  [source,javascript]
  ----
  const { spawn } = require('child_process');
  // If Object.prototype is polluted, this child inherits it
  spawn('node', ['script.js']);
  ----

  Good (Secure)::
  [source,javascript]
  ----
  const { spawn } = require('child_process');
  // Explicitly define env, or use null-prototype objects
  spawn('node', ['script.js'], {
    env: { ...process.env } // Copies current envs; prototype props are ignored
  });
  ----

** Wait for the server to execute any system command (like a maintenance script or image processor).
** The spawned process inherits the polluted `shell` or `NODE_OPTIONS`, giving the attacker a shell or a debug port.

==== 5. The Logic Bypass Chain

Sometimes, the goal isn't to crash the server or steal cookies, but to bypass authorization.

* The Chain:

[cols="1,2,8"]
|===
|Step
|Action|
Result
|1
|Identify a check
|`if (user.permissions.canDelete)`
|2
|Inject Pollution
|`Object.prototype.canDelete = true`
|3
|Execute
|An unprivileged user now passes the `if` check because the property is found on the prototype.
|===

==== How to Break the Chain

To stop these attacks, you must prevent merging or assigning untrusted keys into object prototypes.

* Use `Map`: Instead of plain objects for key-value storage, use `Map`, which isn't susceptible to prototype pollution.
* Null-prototype objects: Use `Object.create(null)` or `Object.setPrototypeOf(obj, null)` for plain dictionaries, so inherited properties cannot be introduced.
* Validation: Use libraries like `joi` or `ajv` to strictly validate the schema of incoming JSON.
* Key filtering: Explicitly reject `__proto__`, `prototype`, and `constructor` in any recursive merge, clone, or path-setter.
* Safe property checks: Use `Object.hasOwn(obj, key)` (or `Object.prototype.hasOwnProperty.call(obj, key)`) instead of `in` when validating keys.
* Child processes: Always pass an explicit `env` when spawning processes, and set `shell: false` unless you truly need a shell.
* Freeze the Prototype: Run `Object.freeze(Object.prototype)` at the very start of your application to prevent any changes (though this can break some legacy libraries).

Hardened merge example:

[source,javascript]
----
function safeMerge(target, source) {
  const deny = new Set(['__proto__', 'prototype', 'constructor']);
  for (const key of Object.keys(source)) {
    if (deny.has(key)) continue;
    const val = source[key];
    if (val && typeof val === 'object' && !Array.isArray(val)) {
      if (!Object.hasOwn(target, key) || typeof target[key] !== 'object') {
        target[key] = Object.create(null);
      }
      safeMerge(target[key], val);
    } else {
      target[key] = val;
    }
  }
}
----
