=== JavaScript Prototype Pollution

==== 1. The Core Injection Chain

Before you can exploit a chain, you have to get the payload in. This usually happens through **recursive merges, path setters,** or **cloning functions**.

**The Logic:**

If an application takes a JSON input and merges it into an existing object without filtering keys, an attacker can send:

```json
{
  "constructor": {
    "prototype": {
      "isAdmin": true
    }
  }
}
```

Once processed, every object in the environment—even a brand new `{}` — will now have `obj.isAdmin === true`.

==== 2. Client-Side: The DOM XSS Chain

On the frontend, prototype pollution is rarely the end goal; it’s a means to trigger **Cross-Site Scripting (XSS)**. This happens by polluting "gadgets" — pieces of code that look for a property and use it in a dangerous sink.

**The Chain:**

. **The Pollution:** Attacker pollutes `Object.prototype.sourceURL = "javascript:alert(1)"`.
. **The Gadget:** A legitimate library (like a slider or tracker) creates a new configuration object.
. **The Vulnerability:** The library checks if `config.sourceURL` exists. Since it’s polluted, it finds the attacker's string.
. **The Sink:** The library passes that string into a script tag or `location.href`.

==== 3. Server-Side: The RCE Chain (Node.js)

In Node.js environments, the stakes are higher. Attackers look for gadgets within the Node.js source or popular modules (like `child_process`) to achieve **Remote Code Execution (RCE)**.

**Common Gadget:** `child_process.spawn`

Many Node utilities use `spawn` or `fork`. These functions often accept an `options` object. If the developer doesn't explicitly define certain environment variables, the system looks them up on the prototype.

* The Chain:
** Pollute `Object.prototype.shell = "/bin/sh"`.
** Pollute `Object.prototype.NODE_OPTIONS = "--inspect-brk=0.0.0.0"`.
*** This payload is a classic example of an *RCE (Remote Code Execution) gadget*. It exploits now Node.js handles environment variables and process spawning.

  The "Pollution" Mechanism::
  When `Object.prototype.NODE_OPTIONS = "..."` is executed, the "base template" of almost every object in the Node.js process can be affected. +
  In Node.js, when a developer uses functions like `child_process.spawn()`` or `child_process.fork()``, the runtime looks for an `options` object to determine how to run the new process. If the developer doesn't explicitly provide an `env` object, or if they provide one that doesn't define `NODE_OPTIONS`, the engine looks up the prototype chain.
  The Payload: `--inspect-brk`::
  The value being injected is a powerful Node.js command-line flag:
  . `--inspect`: Enables the V8 inspector (debugging).
  . `-brk`: Tells the process to "break" (pause) on the very first line of code and wait for a debugger to attach.
  . `0.0.0.0`: This binds the debugger to all network interfaces, making it accessible from the outside world (rather than just `localhost`).
  The Attack Chain::
  The "pollution-to-RCE" chain usually follows these steps:
  . *Injection*: An attacker uses a vulnerable merge or clone function to inject the NODE_OPTIONS string into Object.prototype.
  . *Trigger*: The application performs a routine task that spawns a sub-process (e.g., calling a CLI tool to resize an image, send an email, or run a shell script).
  . *Inheritance*: The spawn() function looks for environment variables. It finds the polluted NODE_OPTIONS on the prototype.
  . *Execution*: The new Node.js process starts, sees the flag, and immediately pauses execution, opening a debugging port on the server.
  . *RCE*: The attacker connects to that port using Chrome DevTools or a Node debugger and executes arbitrary JavaScript code with the same privileges as the server.
  Why is this so dangerour?::
  This is considered a "silent" killer because:
  . *No direct shell needed*: The attacker doesn't need to find a way to run `/bin/sh` directly; they just wait for the app to do its normal job.
  . *Persistence*: Once the prototype is polluted, every subsequent process spawned by that Node.js instance will be "born" in debug mode.
  How to Prevent It::
  The most effective way to stop this specific chain is to ensure that when you spawn child processes, you don't allow them to inherit the global prototype's properties.
  Bad (Vulnerable)::
[source,javascript]
  const { spawn } = require('child_process');
  // If Object.prototype is polluted, this child inherits it
  spawn('node', ['script.js']);

  Good (Secure)::
[source,javascript]

  const { spawn } = require('child_process');
  // Explicitly define env, or use null-prototype objects
  spawn('node', ['script.js'], {
    env: { ...process.env } // This copies current envs, ignoring the prototype
  });

** Wait for the server to execute any system command (like a maintenance script or image processor).
** The spawned process inherits the polluted `shell` or `NODE_OPTIONS`, giving the attacker a  or a debug port.

==== 4. The Logic Bypass Chain

Sometimes, the goal isn't to crash the server or steal cookies, but to bypass authorization.

* The Chain:

[cols="1,2,8"]
|===
|Step
|Action|
Result
|1
|Identify a check
|`if (user.permissions.canDelete)`
|2
|Inject Pollution
|`Object.prototype.canDelete = true`
|3
|Execute
|An unprivileged user now passes the `if` check because the property is found on the prototype.
|===

==== How to Break the Chain

To stop these attacks, you have to prevent the "merging" of untrusted keys

* **Use** `Map`: Instead of plain objects for key-value storage, use `Map`, which isn't susceptible to prototype pollution.
* **Object.create(null)**: Create objects that don't have a prototype at all.
* **Validation**: Use libraries like `joi` or `ajv` to strictly validate the schema of incoming JSON.
* **Freeze the Prototype**: Run `Object.freeze(Object.prototype)` at the very start of your application to prevent any changes (though this can break some legacy libraries).

